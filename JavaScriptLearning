JavaScript

04-03-2014

返回 Boolean 对象的原始值		valueOf()
其他进制转十进制		        parseInt(var,ary)
十进制转其他进制				num.toString(8)
浮点转换			        	parseFloat(string)
字符串转换		        		stringObj.toString(ary)
字符串转换			        	str = String(var)
"undefined"				        NaN
延迟脚本			        	defer="defer"
异步脚本				        async
函数的参数				        arguements						        // 匿名参数,与命名参数使用作为数组存在
相等对象间属性可以传递
查看变量类型		    		typeof				            		// string,number,bolean,object
查看对象类型		    		obj instanceof Object/RegExp/Array		// 返回布尔值
查看错误				        try...catch(err){err.description}
获取域名				        window.location
跳转域名		        		window.location="http://www.google.com"
返回 host 和端口		    	location.host
返回 hostname				    location.hostname
返回锚				        	location.hash
返回完整 href				    location.href
返回当前站点路径			    location.pathname
返回端口			        	location.port
返回 url 协议				    location.protocol   					// http
返回 ? 开始部分	    			location.search
Obj:加载新文档		    		location.assign/replace("http://www.google.com")
Obj:重载文档			    	locatin.reload()
回到前页	        			history.back()
前进一页			        	history.forward()
后退两页			        	history.go(-2)
启动加载			        	window.onload=function() {}
把本地时间转为字符串			oDate.toLocalString
改变字符串的分隔		    	arr.join("|")						    // 变为字符串
合并数组			        	arr1.concat(arr2,arr3)
删除并返回数组最后一元素		arr.pop()					        	// arr.shift() 相反
向数组最后添加数组		    	arr.push(parameter)
颠倒数组元素顺序		    	arr.reverse()
数组元素排序			    	arr.sort(element)					    // 参数是 1 或 -1 或 0
改变文字	        			innerText
取得文字			        	innerHTML
获得随机0~1     				Math.random()
返回选择数组元素    			slice(start,end)
插入删除或替换数组元素			splice(index,howmany,element1,...,elementX)     // element 表示要插入的参数, howmany 为 0 则不删除字符
查找元素位置		    		indexOf(searchvalue,fromindex)/lashIndexOf()
获得年月日时秒分		    	getFullYear/Month/Date/Hours/Minutes/Seconds/Day()	// 定义月份需要 -1

04-04-2104

打开一个窗口					window.open(url,name,feature,replace)		// 类似小广告
打开新页面						<button onclick="javascript:window.open('url')"></button>

window.open("http://www.w3school.com.cn","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, title='new', width=400, height=400")

关闭窗口		        		window.close()
返回窗口高度			    	window.innerheight()
返回窗口宽度			    	window.innerwidth()
返回窗口外部高度			    window.outerheight()
返回窗口名称	    			window.name()
设置窗口状态栏文本	    		window.status=""
用大号字体显示字符串			str.big()
小号字体字符串			    	str.small()
粗体字符串	        			str.bold()
斜体字符串			        	str.italics()
删除线字符串			    	str.strike()
字符串大写		        		str.toUpperCase()
字符串小写				        str.toLowerCase()
字符串下标				        str.sub()
字符串上标			        	str.sup()
字符串链接		        		str.link("http://")

// 声明对象必须一个 new 啊!!!

获得对象的构造函数		    	object.constructor/object instanceof Object/realObject
ECMAScript call() 方法			constructedFunction.call(object,arguement,...)

04-10-2014

获得类名	        			object.className
返回或设置 id		    		anchorObject.id
返回或设置 name			    	anchorObject.name
返回或设置 target			    anchorObject.target
返回或设置 href			    	anchorObject.href
返回文本方向			    	object.dir
返回语言代码			    	element.lang
返回 title 属性			    	object.title
获得焦点			    	    object.focus()
失去焦点				        object.blur()
对数进行下舍入			    	Math.floor(x)
进行上舍入			        	Math.ceil(x)
返回绝对值				        Math.abs(x)
返回反余弦值				    Math.acos(x)
返回反正弦值				    Math.asin(x)
返回余弦			        	Math.cos(x)             // 参数是弧度, Math.PI 1
返回正弦        				Math.sin(x)
返回正切		        		Math.tan(x)
返回e的指数		        		Math.exp(x)
返回自然对数			    	Math.log(x)
返回最大值		        		Math.max(x,y)
返回最小值			        	Math.min(x,y)
返回x的y次幂		    		Math.pow(x,y)
返回0~1随机数			    	Math.random()           // Math.floor(Math.random()*11)  0 ~ 10
四舍五入		        		Math.round(x)
返回平方根			        	Math.sqrt(x)
返回该对象源代码	        	Math.toSource()			// json format like
返回Math对象原始值	    		Math.valueOf()
图像加载被中断  				onabort
元素获得焦点				    onfocus
元素失去焦点			    	onblur
域内内容被改变		    		onchange
点击			        		onclick
双击					        ondblclick
加载发生错误			    	onerror
完成加载			        	onload
鼠标按钮被按下			    	onmousedown
鼠标按钮松开			    	onmouseup
鼠标被移动			        	onmousemove
鼠标移到元素之上		    	onmouseover
鼠标从某元素移开		    	onmouseout
重置按钮被点击			    	onreset
文本被选中		        		onselect
确认按钮被点击		    		onsubmit
用户退出页面		    		onunload
带有 OK 和取消对话框			confirm(message)	    	// 返回 true OR false
输入对话框		    	    	prompt(text,defaultText)
显示确认对话框		    		alert(text)
带上换行符号			    	document.writeIn(x)
离开前询问		        		window.onbeforeunload=function(){return "Really?"}
隐藏元素		    	    	document.(ID).style.visibility='hidden'
显示元素	        			document.(ID).style.visibility='visible'

04-10-2014

从标签名获得		    		getElementsByTagName()
从类名获得			        	getElementsByClassName()
添加字节点			        	appendChild()
删除字节点		        		removeChild()
替换字节点			        	replaceChild()
在指定字节点前面插入新字节点	insertBefore()
创建属性节点			    	document.createAttribute("attributeName")
创建元素节点			    	createElement()
创建文本节点			    	createTextNode()
返回指定属性值			    	getAttribute()
查看对象类      				(Object instanceof String/Function/Class/Array)	// true OR false
查看变量类型				    typeof var                  // http://mzl.la/1qJzwPI , 结果: undefined,object,boolean,number,string,implementation-dependent,function,xml

04-11-2014

(1234622225).toLocaleString("zh-Hans-CN-u-nu-hanidec")      //firefox下输出 "1,234,622,225",IE与chrome下输出 "一,二三四,六二二,二二五"

04-12-2014

把内容滚动到指定坐标            srollTo(xpos,ypos)          // window.srollTo(0,0)

04-16-2014

域内容改变时变化				input.onChange()=function() {str.toUpperCase()};
下拉条选项						document.form.Drop.selectedIndex			// 索引从 0 开始
下拉条项目数					document.form.Drop.length
下拉条第 n 项					document.form.Drop.option[0].value			// value 定义发送到服务器的值
下拉选项值						document.form.Drop.option[0].text
创建新的 HTML 元素

<div id="div1">
<p id="p1">这是一个段落</p>
<p id="p2">这是另一个段落</p>
</div>

<script>
var para=document.createElement("p");
var node=document.createTextNode("这是新段落。");
para.appendChild(node);

var element=document.getElementById("div1");
element.appendChild(para);
</script>

创建新元素                      var para = document.createElement("p");
创建新元素节点                  var node = document.createTextNode("new paragraph");
追加元素节点                    para.appendChild(node);
追加元素                        document.getElementById("div").appendChild(para);
移除元素                        document.getElementById("div").removeChild(document.getElementById("p");
移除节点                        removeChild()
返回当日日期时间                Date()
返回一个月某一天                getDate()
返回一周某一天                  getDay()
返回月份                        getMonth()
返回四字年份                    getFullYear()
返回小时                        getHours()
返回分钟                        getMinutes()
返回秒                          getSeconds()
返回毫秒                        getMilliseconds()
返回1970/1/1 至今毫秒           getTime()
返回本地时间和 GMT 分钟差       getTimezoneOffset()
返回 UTC 日                     getUTCDate()
返回 UTC 星期                   getUTCDay()
返回 UTC 月份                   getUTCMonth()
返回 UTC 年份                   getUTCYear()
返回 UTC 小时                   getUTCHours()
返回 UTC 分钟                   getUTCMinutes()
返回 UTC 秒                     getUTCSeconds()
返回 UNIX 时间到指定日期毫秒    parse()
设置月某一天                    setDate()
设置月份                        setMonth()
设置年份                        setFullYear()
设置小时                        setHours()
设置分钟                        setMinutes()
设置秒                          setSeconds()
设置毫秒                        setMilliSeconds()
以毫秒设置 Date                 setTime()
设置 UTC 时间                   setUTCDate()/Month()/Day()/FullYear()
返回对象源代码(类似 json 格式)  object.toSource()
把 Date 对象时间部分转为字符串  toTimeString()
把世界时转为 String             toUTCString()
把本地时间部分转为 String       toLocaleString()
把日期部分转为 String           toLocaleDateString()
根据世界时返回 UTC 时间毫秒     UTC()
返回 Date 对象原始值            valueOf()
返回 Boolean 对象原始值         booleanObject.valueOf()

<script type="text/javascript">

var boo = new Boolean(false)
document.write(boo.valueOf())

</script>

返回一个整数值代表当前节点类型  Node.nodeType

常量名	                        值
ELEMENT_NODE	                1
ATTRIBUTE_NODE	                2
TEXT_NODE	                    3
CDATA_SECTION_NODE	            4
ENTITY_REFERENCE_NODE	        5
ENTITY_NODE	                    6
PROCESSING_INSTRUCTION_NODE	    7
COMMENT_NODE	                8
DOCUMENT_NODE	                9
DOCUMENT_TYPE_NODE	            10
DOCUMENT_FRAGMENT_NODE	        11
NOTATION_NODE	                12

nodeName 包含某个节点名称

元素节点的 nodeName 是标签名称
属性节点的 nodeName 是属性名称
文本节点的 nodeName 永远是 #text
文档节点的 nodeName 永远是 #document

nodeValue

对文本节点，nodeValue 属性包含文本
对属性节点，nodeValue 属性包含属性值
nodeValue 属性对于文档节点和元素节点是不可用的

添加修改删除文本节点内容            text.nodeValue=text.nodeValue+" abc";           // 需要先 .childNodes 获得子节点

打印数组                            alert(arr.toString())
打印数组                            alert(arr.join("|")
返回 document 的子节点的 NodeList   documentObject.childNodes
加载 xml 文档                       loadXMLDoc("xmlPath")
获取元素的属性的字节点集合          .attributes

04-17-2014

nodeType nodeName nodeValue 例子    http://bit.ly/1qJR0eF

// getElementsByTagName() 返回包含 tagname 的所有元素的一个 NodeList，首先选出对应元素，再通过childeNodes操作子节点
// getElementsByClassName() 返回包含 class 的所有元素的一个 NodeList，首先选出对应元素，再通过childeNodes操作子节点

04-19-2014

在指定毫秒数后调用函数或计算表达式  setTimeout(code,millisec)
DOM 选择器(选择第一个)              querySelector(class/id)
DOM 选择器返回数组                  querySlectorAll(class/id)

04-21-2014

加载发生错误时被触发				<img src="image.gif" onerror="alert('The image could not be loaded.')" />
查找字符串中一节字符串位置			stringObject.indexOf(searchValue,fromindex)

// 返回字符位置从0开始，没有则返回 -1

提取字符串结余两指定下标之间字符	stringObject.substring(start,stop)			// 不接受负数参数
提取字符串的某个部分并返回			stringObject.slice(start,end)				// 接受负数参数
抽取从 strat 下标指定数目字符		stringObject.substr(start,length)
把字符串分割成字符串数组			stringObject.split(separator,howmany)
JavaScript 对象						document. image, link, textarea

04-22-2014

添加新类							document.getElementById("comn").className+=" comn";

04-25-2014

String 变大写                       String.toUpperCase()
String 变小写                       String.toLowerCase()

04-26-2014

编辑文档内容                        (Console) javascript:document.body.contentEditable="true";
阻止浏览器默认行为                  <a href="javascript:void(0)/javascript:return false;"></a>                          // JavaScript 中 void 是一个操作符，该操作符指定要计算一个表达式但是不返回值
void 运算符对任何值返回 undefined   <a href="javascript:void(window.open('about:blank'))">Nothing happens</a>

======================================
"-" 将 String 变为 Integer
---------------------------
var str = "3";
console.log(typeof str);    // string
str = -str;
console.log(typeof str);    // number
======================================

04-27-2014

判断原始类型 (primitive type)           typeof(crap)      // Undefined, Number, String, NULL, Boolean
引用类型 (Reference type) / NULL        object

// 函数无明确返回值时，返回的值为 undefined
// console.log(null == undefined);      // true

八进制, 十六进制                        070, 0x70
十六进制 10~15                          A, B, C, D, E, F
表示小数                                5.618e-9
判断一个参数是否有限数字                isFintie(Number.MAX/MIN_VALUE)
查看是否非数 (not a number)             isNaN("blue")                                                                   // 注意: NaN != NaN  true, 不能用 "blue" == NaN 进行判断

====== ECMAScript 字符字面量 ===============

字面量	含义
\n  	换行
\t  	制表符
\b  	空格
\r  	回车
\f  	换页符
\\  	反斜杠
\'  	单引号
\"  	双引号
\0nnn	八进制代码 nnn 表示的字符（n 是 0 到 7 中的一个八进制数字）
\xnn	十六进制代码 nn 表示的字符（n 是 0 到 F 中的一个十六进制数字）
\unnnn	十六进制代码 nnnn 表示的 Unicode 字符（n 是 0 到 F 中的一个十六进制数字）
==============================================

// toString 会将浮点型转换为整型

通过指定分隔符将数组元素转换为字符串    console.log(objectArray.join("|"))
直接输出数组                            console.log(objectArray) == console.log(objectArray.join(",")) == console.log(objectArray.toString())
Boolean 转为字符                        objectObject.toString()
Date 对象转字符串                       objectDate.toString()
Date 对象原始值(from 1970/1/1 00:00)    objectDate.valueOf()
Number 转换字符串                       NumberObject.toString()
                                        DateObject.toLocaleString
// toLocaleString 方法返回一个 String 对象，这个对象中包含了用当前区域设置的默认格式表示的日期。比如："2014年4月27日 下午9:06:38"。此外还有 toLocalDateString() 和 toLocalTimeString() 分别对应日期和时间

转为整型                                parseInt()                                                                      // isNaN(parseInt("red")) == true  parseInt("56.9") == 56

04-28-2014

强制转换为 Boolean                      var b = Boolean(""/"hello"/null/0/new object());                                // true/false
强制转换为 Number                       var n = Number(false/true/undefined/null/"1.2"/"1.2.3"/new object()/50);        // 0/1/exact number/NaN
强制转换为 String                       var str = String(null/undefined/false/...);                                     // "null", "undefined", "false"

======================= 注意： ==========================
try {
    var oNull = null; 
    var str = oNull.toString(); 
} catch(err) {
    console.log(err);       // TypeError: Cannot read property 'toString' of null
}
=========================================================

返回 true 或 false 的确认取消框并进行   if(!confirm(Ready?)) { window.history.back()/forward()/go(-2) }

============== 自定义错误(创建/抛出异常) ===================
<script>
try {
  var x=document.getElementById("demo").value;
  if(x=="")    throw "empty";
  if(isNaN(x)) throw "not a number";
  if(x>10)     throw "too high";
  if(x<5)      throw "too low";
} 
catch(err) {
  var y=document.getElementById("mess");
  y.innerHTML="Error: " + err + ".";
}
==============================================================

/* 皆不改变字符串自身的值，从返回值中取得。*/

返回具有指定位数小数的数字的字符串表示  oNumberObject.toFixed(2)            // 68.00(四舍五入)
返回科学计数法 e                        oNumberObject.toExponential(1)      // 6.8e+1(四舍五入)
根据最有意义形式返回数字或指数形式      oNumberObject.toPrecision(1)        // 7e+1 (四舍五入)
String valueOf() 和 toString()          oStringObject.valueOf()==oStringObject.toString()
返回指定字符串字符                      oStringObject.charAt(2)             // "t"
返回指定字符串字符代码                  oStringObject.charCodeAt(9)         // "101" => "e"
把字符串+连到 String 对象原始值上       oStringObject.concat(" world.")     // "Hello world."
返回字符在字符串开头开始位置            oStringObject.indexOf("S")          // 1, 不存在返回 -1
返回字符在字符串结尾开始位置            oStringObject.lastIndexOf("S")      // 11
对字符串进行排序                        oStringObject.localeCompare("yellow/blue/zoo")
/* localeString()
 * 如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。
 * 如果 String 对象等于参数中的字符串，返回 0
 * 如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。
*/
从子串创建字符串值                      oStringObject.substring/slice("2","5")  // "tring"

// slice() 可以处理负数, substring()会将负数转为 0, oStringObject.substring("-2") == oStringObject

// typeof 原始类型正确返回, 引用类型全部返回 object, 此时用 instanceof 进行判断

判断引用类型                            oStringObject instanceof String/Number/Array/Boolean
使有能力向对象添加属性和方法            object.prototype.name=value             // object.name=value

======================= prototype =====================
<script type="text/javascript">

function employee(name,job,born)
{
this.name=name;
this.job=job;
this.born=born;
}

var bill=new employee("Bill Gates","Engineer",1985);

employee.prototype.salary=null;
bill.salary=20000;

document.write(bill.salary);        // 20000

</script>
==========================================================

删除对以前定义的对象类型或方法的引用        delete o.name

04-29-2014

左移/赋值                                   <<=
有符号右移/赋值                             >>=
无符号右移/赋值                             >>>=
严格的迭代语句枚举对象的属性                for(property in expression) statement

===================== for-in =====================

for(sProp in window); console.log(sProp);

==================================================

给语句加标签以便以后调用 (break/continue)   label:statement

==================== with ========================
// with 语句用于设置代码在特定对象中的作用区

var sMessage = "hello";
with(sMessage) {
  console.log(toUpperCase());   // 输出 "HELLO"
}

// with 是运行缓慢的代码块，尤其是在已设置了属性值时。
   大多数情况下，如果可能，最好避免使用它。
==================================================

============ ECMAScript arguements 对象===========

function howManyArgs() {
  console.log(arguements.length)
}

howManyArgs("string",45);       // 2
console.log(arguements[0]);     // "string"
howManyArgs();                  // 0
howManyArgs(12);                // 1
==================================================

定义 Function 对象 (类)                     function sayHi(sName,sMessage){ alert(sName); }
定义 Function 对象 (类)                     var sayHi=new Function("sName","sMessage","alert(sName);");
等于对象为等于其指针                        var alsodoAdd=doAdd         // pointer
获得函数期望的参数个数                      console.log(oFunctionObject.length)
打开新窗口                                  windowVar=window.open(URL,windowName,[,windowFeature])
到达锚点                                    window.location.hash="anchorName"
用正则进行判断                              pattern.test(String)        // true OR false
第一个被正则匹配的位置                      pattern.match(String)       // index
正则替换                                    String.replace(pattern,"#")
正则分开成数组                              String.split(/\D+/)
正则表示                                    /d+/ig                      // i: 不区别大小  g: 全局
获取 Cookie                                 console.log(unescape(strCookie.split("; ")[1].split("=")[1])); 

04-30-2014

查找父辈元素                                obj.parentNode
查找指定类型 type                           getElementsByTagName("input[type='text']")
选中 input 的值                             inputName.select()
获取上传文件最后修改时间                    f[0].lastModifiedDate
获取上传文件名称                            f[0].name
获取上传文件大小                            f[0].size
获取上传文件类型                            f[0].type
获取指定数组元素                            arrObj.slice('start','end')
修改表格内容                                document.getElementById("tb").rows(r).cells(d).innerHTML = c

============== HTML DOM Node Type ===============================
Node Type                   nodeName returns        nodeValue returns

1  Element	                element name	        null
2  Attr	                    attribute name	        attribute value
3  Text	                    #text	                content of node
4  CDATASection	            #cdata-section	        content of node
5  EntityReference	        entity reference name	null
6  Entity	                entity name	            null
7  ProcessingInstruction	target	                content of node
8  Comment	                #comment	            comment text
9  Document	                #document	            null
10 DocumentType	            doctype name	        null
11 DocumentFragment	        #document fragment  	null
12 Notation	                notation name	        null
================================================================

创建元素节点 (Element Node)                     document.createElement("LI")
创建文本节点 (Text Node)                        document.createTextNode("Water")
给元素节点添加文本子节点                        elementNode.appendChild(textNode)
给文档节点添加创建好的节点                      document.getElementById("identification").appendChild(node)

05-01-2014

相当于对节点进行点击作用                        document.getElementById("w3c").accessKey="w"
获得节点的属性组                                document.getElementsByTagName("BUTTON")[0].attributes[0].nodeValue/nodeType/nodeName/attributes.length
返回子节点                                      document.getElementsByTagName("P")[0].childNodes.nodeName       // #text
返回子节点                                      document.body.childNodes

// 利用 childNodes 获得子节点将会返回 ElementNodes 和 TextNodes, 其中对应的 TextNodes 又属于 ElementNodes 的子节点 (http://bit.ly/R0DB5E)

获取 className                                  document.getElementsByTagName("BODY")[0].className
克隆一个节点 (element.cloneNode(true/false))    document.body.appendChild(document.getElementsByTagName("H1").lastChild.cloneNode(true))

================= compareDocumentPosition =================

var p1 = document.getElementsByTagName("P")[0];
var p2 = document.getElementById("p2").lastChild;
var x = document.getElementById("demo");
x.innerHTML = p1.compareDocumentPosition(p2);   // 4

1 (No relationship, the two nodes do not belong to the same document)

2 (The first node (p1) is positioned after the second node (p2))

4 (The first node (p1) is positioned before the second node (p2))

8 (The first node (p1) is positioned inside the second node (p2))

16 (The second node (p2) is positioned inside the first node (p1))

32 (No relationship, or the two nodes are two attributes on the same element)

===========================================================

获得/设置文字对齐方向                           document.body.dir
获得第一个子节点                                document.firstChild.nodeName                                            // html
获得/设置 attribute (方法)                      document.getElementsByTagName("a")[0].getAttribute("target")            // "_blank", 直接返回 value, 下面的需要加上调用 value 属性
获得/设置 attribute 节点 (方法)                 document.getElementsByTagName("a")[0].getAttributeNode("target").value
查看是否拥有某种 attribute                      document.getElementsByTagName("button")[0].hasAttribute("onclick")      // true | false
查看是否拥有 any attributes                     document.getElementsByTagName("button")[0].hasAttributes("attrName")              // true | false
查看是否拥有子节点                              document.getElementById("mylist").hasChildNodes()                       // true | false
获得 element 的 id value                        document.getElementById("myAnchor").id                                  // myAnchor
返回/设置 inner HTML                            document.getElementById("myAnchor").innerHTML="W3Schools"
设置 elements 的 attributes                     document.getElementById("myAnchor").href="http://www.w3school.com"; document.getElementById("myAnchor").target="_blank"
在指定 node 前插入新 node                       document.getElementById("myList").insertBefore(newItem, existingItem);

// existingnode	Node object	Optional. The child node you want to insert the new node before. When not specified, the insertBefore method will insert the newnode at the end

返回最后子节点                                  document.getElementById("myAnchor").lastchild
返回下一个节点                                  document.getElementById("items1").nextSibling.nodeName
返回上一个节点                                  document.getElementById("items2").previousSibling.nodeName
标准化节点                                      node.normalize()

// normalize() method 会将空文本节点移除掉, 将相近的文本节点合并

返回 node 的 owner document                     document.getElementById("demo").ownerDocument;

// 在 HTML 文档中，文档本身永远是一个元素的 ownerDocument (根节点)，nodeType = 5

获得父节点                                      document.getElementById("item1").parentNode
移除指定 attribute                              document.getElementsByTagName("H1")[0].removeAttribute("style")

05-02-2014

移除 Attribute 节点                     document.getElementsByTagName("input")[0].removeAttributeNode(document.getElementsByTagName("input")[0].getAttributeNode("type"))
移除子节点                              document.getElementById("myList").removeChild(document.getElementById("myList").childNodes[0])

========================== 子节点替换 replaceChild(newNode,oldNode) =======================

var textnode = document.createTextNode("Water");
var item = document.getElementById("myList").childNodes[0];
item.replaceChild(textnode,item.childNodes[0]);

===========================================================================================

// 文本属于它所在标签的子节点, 一级级严格作为节点存在

通过 setAttribute() 方法设置 attribute节点  element.setAttribute(attributeName, attributeValue)

=========== setAttribute() ==============

document.getElementsByTagName("INPUT")[0].setAttribute("type","button")

=========================================

设置 attribute 节点                         element.setAttributeNode(attributeNode)

================= setAttributeNode() ===============

var atr=document.createAttribute("class");
atr.nodeValue="democlass";
document.getElementsByTagName("H1")[0].setAttributeNode(atr);

====================================================

设置/返回元素的标签顺序 (从 0 开始)         HTMLElementObject.tabIndex.teaIndex=tabIndex
返回元素的标签名 (类似 nodeName)            document.getElementById("demo").tagName             // P
设置/返回特定节点的文本子节点和它的所有后代 document.getElementById("myList").textContent       // 注意: 设置文本子节点时如果同时有已存在的子节点则所有子节点都会被清空并以新文本节点进行代替
在 node list 中返回指定 index 的 node       document.body.childNodes.item(0)                    // document.body.childNodes[0]
返回/设置元素的 title 属性值                HTMLElementObject.title=title document.title
返回 document 所有锚点                      document.anchors.length
返回指定锚点                                document.anchors[0].length

05-03-2014

document.open()
document.close()
创建属性                                    document.createAttribute("class").value="democlass"
创建注释                                    document.body.appendChild(document.createComment("My personal comments"))
创建节点片段                                document.createDocumentFragment()
创建文本节点                                document.createTextNode(text)
创建元素节点                                document.createElement(nodeName)
返回 HTML document 的 doctype object        document.doctype                        // html
返回 HTML document 的文档节点               document.documentElement.nodeName       // HTML
返回浏览器渲染模式 (For IE only)            document.documentMode                   // 5=>IE5, 6=>IE6, 7=>IE7, 8=>IE8, 9=>IE9
返回当前文档服务器域名                      document.domain                         // www.youngdze.com
返回当前文档所有 form 的集合以数组形式      document.forms[].property
设置指定属性值                              element.setAttribute("attrName","attrValue")    // 常和 hasAttribute("attrName") 一起用
改变 checked 状态                           inputElement.checked=true/false;                // if(document.getElementsByTagName("INPUT")[0].checked)
通过 Name 返回 name list                    document.getElementsByName(name)[].property
返回 img collection                         document.images[].property
返回 DOM implementation                     document.implementation
任何 full URL of the document               document.URL

// document.writeln()   Same as write(), but add a newline character (\s) after each statement

================== event clientX & clientY ===============

function show_croods(event) {
  var x=event.clientX;
  var y=event.clientY;
  alert("X coords: "+x+", Y coords: "+y);
}

==========================================================

双击触发                                        onblclick()
GMT Time                                        Thu, 01 Jan 1970 00:00:00 GMT
通过 className 查找                             document.getElementsByClassName(className)
类字符串函数创建                                var func_multiply = new Function("arg1","arg2","return arg1 * arg2;"); func_multiply(5,10);     // => 50

05-04-2014

javascript:                                     <button onClick="javascript:alert('Hello world');"></button>
选择框架                                        top.frames["frameName"]
返回框架 list                                   window.frames[].property
框架地址改变 (AJAX)                             window.frames[0].location="http://www.w3schools.com"

============== AJAX similar ============
<button onclick="changeFrame()">Change the src property of every frame</button>
<iframe src="http://www.cnn.com"></iframe>
<iframe src="http://www.bbc.com"></iframe>
<iframe src="http://www.nytimes.com"></iframe>

<script>
function changeFrame() {
  for (var i=0; i<frames.length; i++) {
    frames[i].location="http://www.w3schools.com"
  }
}
</script>
========================================

允许一个事件执行多个动作 (Mozilla Only)         target.addEventListener(type, listener[, userCapture]); target.addEventListener(type, listener[, useCapture, wantsUntrusted ]);    // Gecko/Mozilla only
移除监听事件                                    removeEventListener(event,function,capture/bubble) | detachEvent(event,function)

================== HTML DOM Events ================

<script>
function changetext(identification) {
  identification.innerHTML="Ooops!";
}
</script>

<h1 onclick="changetext(this)">Click on this text!</h1>

===================================================

============ addEventListener =====================

<button id="mybtn">My Button</button>
<button id="mybtn2">Hover Button</button>

<script>
  function addListeners() {
    if (window.addEventListener) {
      document.getElementById("mybtn").addEventListener("click",btn1func,false);
      document.getElementById("mybtn2").addEventListener("mouseover",btn2func,false);
    } else if (window.attachEvent) {
      document.getElementById("mybtn").attachEvent("onclick",btn1func);
      document.getElementById("mybtn2").attachEvent("mouseover",btn2func);
    }
    function btn1func() {
      alert(this.id+" : mouse-click makes script run");
    }
    function btn2func() {
      alert(this.id+" : mouse-click makes script run");
    }
  }
  window.onload = addListeners;
</script>

====================================================

启动加载                                            window.onload | document.body.onload (Firfox inaction)
=============== 可多次添加启动加载函数 addLoadEvent() ================

/******* addLocadEvent() start *********/
function addLoadEvent(func){
  var oldonload = window.onload;
  if (typeof window.onload != "function") {
    window.onload = func;
  } else {
    window.onload = function(){
      oldonload();
      func();
    }
  }
}
/******* addLocadEvent() end *********/

function popup() { window.alert("Hello"); }
function popup2() { window.alert("world!"); }
addLoadEvent(popup());
addLocadEvent(popup2());

======================================================================

老的微软专属 id 选择器 (old school)                     document.all.[idName]
返回当前元素左边界到它的包含元素左边界偏移量            element.offsetLeft
返回当前元素上边界到它的包含元素上边界偏移量            element.offsetTop
返回对最近动态定位的包含元素的引用所有偏移量由此决定    element.offsetParent        // node
原生 JavaScritp 选择器 (非常类似 jQuery $)              document/element.queryselector("li.animal | #animal")
返回元素宽度 (px)                                       element.offsetWidth
返回元素高度 (px)                                       element.offsetHeight

05-06-2014

解释运行源码组成的字符串并产生一个值                    eval("3+2")
delete 删除方法                                         delete prototype        // 不能删除 var 定义,返回 false
定义全局对象属性                                        this.x=1
for 空语句在后面加 ;                                    for(var i=0;i<x.length;x[i++]=0) ;
一个函数只有一个 return 可以 没有 expression            functino display_object(o){if(!o) return;}      // undefined
抛出异常立即停止当前逻辑跳至就近异常处理程序            try{ if(x<1) throw [new Error]("statement") } catch(err/e/ex) {}

============ user-defined object ============

var empty = {};
var point = { x:0, y:0 };
var point2 = { x:point.x, y:point.y+1 };
var book = {
  "main title" : "JavaScript",          // 必须用 quote 因为有 \s 或 其他符号 或 保留字 (for)
  'sub-title' : 'The Definitive Guide',
  "for" : "all audiences",
  author : {
    firstname : "David",
    surname : "Flanagan"
  }
};

============================================

通过 new 创建对象                                   var o = new Object()/Array()/Date()/RegExp("js");
所有对象拥有三个相关对象属性 (object attribute)     prototype & class & extensible flag

05-07-2014

拼写错误                                            TypeError()
定义错误                                            var e=new Error("Could not parse input)
抛出错误                                            throw e
错误 prototype.message                              Error.prototype.message
定义 Error 名称                                     Error.prototype.name        // e.name = "Parse Error"
Error 以 String 输出                                Error.toString()            // like throw e

// TypeError 和 Error protytype 一样, TypeError.prototype.message/name/fileName/lineNumber/columnNumber/stack

属性设置                                            var author=book.author/book["author"]
属性查询                                            book.author/book["author"]  // 后者为字符串形式,所以可改

========== 计算 portfolio ==========

function getvalue(portfolio) {
  var total = 0.0;
  for(stock in portfolio) {
    var shares = portfolio[stock];
    var price = getquote(stock);
    total += shares * price;
  }
}

====================================

============ 检测存在属性 ===========

var o = { x:1 }
"x" in o            // true
"y" in o            // false
"toString" in o     // true inherit

=====================================

检测存在属性                                        o.hasOwnProperty("toString")
检测可枚举属性 (继承不算)                           o.propertyIsEnumerable("x")
更简单的检测属性                                    o.x !== undefined       // 遇到 undefined 属性需要用 in 补充

======== 枚举属性 ==========

var o = {x:1, y:2, x:3}
o.propertyIsEnumerable("toString")
for(p in o)
console.log(p)

============================

// 自有属性(可枚举), 继承属性(不可枚举)

类型错误                                            throw TypeError

========== merge tow object ==========

function merge(o,p) {
  if(typeof o != "object" || typeof p != "object")
    throw TypeError;
  for(prop in o) {
    if(p[prop]) {
      continue;
    } else {
      p[prop] = o[prop];
    }
  }
}

======================================

对象继承                                            var q = inherit(p)
查看一个对象是否为某个构造函数                      v instanceof Vehicle
避免代码块识别错                                    ({}) instanceof Vehicle     // true

// 是某个构造函数的示例

=========== 阶乘计算 ============

function factorial(x) {
  if(x <= 1) return 1;
  return x * fatorial(x-1);
}

=================================

========= 两个笛卡尔坐标距离计算 ============

function distance(x1,y1,x2,y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(Math.pow(dx,2)+Math.pow(dx,2))
}

=============================================

创建函数实例方法                                    function multiply(){} / var product = multiply() / var example = function(){}

05-08-2014

动态指定函数或方法的调用对象                        dog.shout.call/apply.call(cat)      // dog.shout 方法将动态应用到 cat 上
查看对象所用的构造函数                              dog.constructor

05-09-2014

调用一个对象一个方法以另一个对象替换当前对象        call(thisObj[, arg1[, arg2[, [, argN]]]])
应用某一对象一个方法以另一对象代之                  apply([thisObj[, argArray]])        // 注意，传入的参数必须为数组
直接在对象定义一个新属性或修改已存在属性并返回      Object.defineProperty(obj, prop, descriptor)

================== Object.defineProperty ==================

var person = {};
Object.defineProperty(person,"name",{
  writable/configurable/enumerable: false(default)/true,
  __proto__: null,
  value: "Nicholas"
});

===========================================================

05-10-2014

不可扩展对象                                        Object.preventExtensions(objName)
同样指向原型                                        var proto = obj.__protp__
只指定 get 只读 / set 只写                          get: function() {return value}, set:function() {}
不能删除 prototype 定义对象                         C.prototype.x = 12; delete o.x      // false
不能删除 var 和 function 声明函数                   function foo() { return 42; }; delete foo;  // false
非标准 get                                          book.__defineGetter__("year", function(){ return this._year; });
非标准 set                                          book.__defineSetter__("year", function(newValue){ this._year = newValue; });
定义多个属性                                        defineProperties

================ Object.defineProperties() ================

var book = {};

Object.defineProperties(book, {
  _year: {
    valur: 2004
  },
  edition: {
    value: 1
  },
  year: {
    get: function() {
      return this._year
    },
    set: function(newValue) {
      if(newValue > 2004) {
        this._year = newValue,
        this.edition += newValue - 2004
      }
    }
  }
});

===========================================================

读取属性的特性                                  Object.getOwnPropertyDescriptor(object, propertyname)

================= Object.getOwnPropertyDescriptor() ==================

var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
console.log(descriptor.value);
console.log(descriptor.configurable);
console.log(description.get);       // undefined

======================================================================

=============== 工厂模式 ===============

function createPerson(name, age, job) {
  var o =new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log("My name is "+this.name);
  };
  return o;
}

var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");

========================================

原生构造函数                                    Object, Array, Function

==================== 构造函数 ====================

function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log("My name is "+this.name);
  }
}

var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Grey", 27, "Doctor");

==================================================

// 构造函数(类)首字母大写,费构造函数应该首字母小写

打开新 about:blank 页面                         javascript:window.open()
打开 stream                                     document.open()
关闭 stream                                     document.close()
写入 stream                                     document.write()

// When opening a window with the window.open() method, you can use this property window.opener from the destination window to return details of the source (parent) window.

替换当前页面                                    window.open("", "_self")
关闭 open 的窗口                                newWindow.close()
打开新窗口                                      window.oepn(URL, name, specs, replace)

=============== 新窗口运行代码 =================

<html>
  <script>
  function run_code() {
    var code = document.getElementById("ohmy_code").value;
    var newWindow = window.open();
    newWindow.document.open();
    newWindow.document.write(code);
    newWindow.document.close();
  }
  </script>
  <body>
  <input type="button" value="运行代码显示结果" onclick="run_code()"/><br/>
  <textarea id="ohmy_code" cols="100" rows="10"></textarea>
  </body>
</html>

================================================

05-11-2014

=================== 立即执行函数 ==================

(function xxx() {
 
   // function body

 })();

相当于:

function xxx() {
  // function body
}
xxx();

===================================================

// 每个函数都有一个 prototype 属性, 这个属性是这项一个对象的引用, 这个对象称为原型对象, 原型对象包含函数实例共享的方法和属性, 也就是说函数用作构造函数调用 (使用 new 操作符调用) 的时候, 新创建的对象会从原型对象上继承属性和方法。

// JavaScript 函数作用域, 在函数内定义的变量和函数如果不对外提供接口, 那么外部将无法访问到, 也就是变为私有变量和私有函数。

// ( C 语言) 局部变量在添加了 static 的类型限制之后, 就相当于全局变量, 函数调用完了之后, 修改过的局部变量的值仍然是有效的。而如果不加 static 的类型限制, 会为动态局部变量。

// ( C 语言) 全局变量(外部变量)的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式, 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在与非静态全局变量的作用域是整个源程序, 当一个源程序有多个源文件组成时, 非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域, 即只在定义该变量的源文件内有效, 在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内, 只能为该源文件内的函数公用, 因此可以避免在其他原文件中引起错误。从以上分析可以看出, 把局部变量改变为静态变量是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域, 限制了它的使用范围。因此 static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

// 在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法, 实例化后可以访问, JavaScript 也能做到这样。

============= 以上 ================

function Obj() {
  this.a = [];                      // 实例变量
  this.fn = function() {};          // 实例方法
}

console.log(typeof Obj.a);          // undefined  必须实例化
console.log(typeof Obj.fn);         // undefined  必须实例化

var o = new Obj();
console.log(typeof o.a);            // object
console.log(typeof o.fn);           // function

===================================

// 在函数内部不用 var 声明变量该变量将作为全局变量存在, 使用 var 将作为局部变量存在。

=============== 静态变量、函数 ==============

function Obj() {};

Obj.a = 0;                  // 静态变量
Obj.fn = function() {};     // 静态函数

console.log(Obj.a);         // 0
console.log(typeof Obj.fn); // function

var o = new Obj();
conosle.log(o.a);           // undefined
console.log(typeof o.fn);   // undefined

=============================================

// 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，默认情况下prototype属性会默认获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针。

// 当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（很多浏览器这个指针名字为__proto__）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。

// 构造函数 Person 对象会自动获得 prototype 属性, 而 prototype 也是一个对象, 会自动获得一个 constructor 属性, 该属性正是指向 Person 对象。

======================= 以上 ========================

http://www.cnblogs.com/dolphinX/p/3286177.html

function Person(name,age) {
  this.name = name;
  this.age = age;
  this.sayInfo = function() {
    console.log("My name is "+this.name+" and my age is "+this.age+".");
  }
}

Person.prototype                    // Person()
Person.constructor                  // function Function() { [native code] }

Person.prototype.constructor        // function Person(name,age){ this.name = name; this.age = age; this.sayInfo=function(){ console.log("My name is "+this.name+" and my age is "+this.age+"."); }}

var per = new Person("Nick",23);

per.__proto__                       // Person()  __proto__ 是指向 prototype 的指针

per.constructor                     // function Person(name,age){ this.name = name; this.age = age; this.sayInfo=function(){ console.log("My name is "+this.name+" and my age is "+this.age+"."); }}

Person.prototype.printName = function() { console.log("My name is "+this.name+"."); };

======================================================

// 构造函数构造完成后需要新添加属性需用 prototype

================== 简单的 $ 选择器实现 ==================

(function() {
  var _$ = function(attr) {
    return document.querySelector(attr);
  }
  window.$ = _$;
})();

=========================================================

/* delete 不能删除对象
 * 1. 声明的变量( 变量、函数、函数参数) 不能删除; 如: var x = 1;
 * 2. 内置对象的属性不能删除; 如: Math.PI
 * 3. 定义变量属性的 configurable 为 false 的, 不能删除。
*/

// 需要注意的内置对象有 Date 和 Math

=================== jQuery source codes ====================

http://www.cnblogs.com/dolphinX/p/3270779.html
-----------------------------------------------

(function( window, undefined ) {
   
  var jQuery = (function() {
     // 构建jQuery对象
     var jQuery = function( selector, context ) {
       return new jQuery.fn.init( selector, context, rootjQuery );
     }
   
     // jQuery对象原型
     jQuery.fn = jQuery.prototype = {
       constructor: jQuery,
       init: function( selector, context, rootjQuery ) {
        // selector有以下7种分支情况：
        // DOM元素
        // body（优化）
        // 字符串：HTML标签、HTML字符串、#id、选择器表达式
        // 函数（作为ready回调函数）
        // 最后返回伪数组
       }
     };
   
    //把jQuery的prototype赋值给init方法的prototype
     jQuery.fn.init.prototype = jQuery.fn;
   
     // 合并内容到第一个参数中，后续大部分功能都通过该函数扩展
     // 通过jQuery.fn.extend扩展的函数，大部分都会调用通过jQuery.extend扩展的同名函数
     jQuery.extend = jQuery.fn.extend = function() {};
    
     // 在jQuery上扩展静态方法
     jQuery.extend({
       // ready bindReady
       // isPlainObject isEmptyObject
       // parseJSON parseXML
       // globalEval
       // each makeArray inArray merge grep map
       // proxy
       // access
       // uaMatch
       // sub
       // browser
     });

     return jQuery;
   
  })();
   
  window.jQuery = window.$ = jQuery;
})(window);

============================================================

05-12-2014

======================== 闭包 ============================

// 将内部函数指定给一个全部变量

var globalVar;
  function outerFn() {
    console.log("Outer function");
    function innerFn() {
      console.log("Inner function");
    }
  }
outerFn();
globalVar();

// 通过在父函数的返回值来获得内部函数引用
// 这种即使离开函数作用域的情况下仍然能够通过引用调用内部函数的事实，意味着只要存在调用内部函数的可能，JavaScript就需要保留被引用的函数。而且JavaScript运行时需要跟踪引用这个内部函数的所有变量，直到最后一个变量废弃，JavaScript的垃圾收集器才能释放相应的内存空间。

function outerFn() {
  console.log("Outer function");
  function innerFn() {
    console.log("Inner function");
  }
  return innerFn;
}

var fnRef = outerFn();
fnRef();

===========================================================

// 闭包是指有权限访问另一个函数作用域的变量的函数, 创建闭包的常见方式就是在一个函数内部创建另一个函数。

/* 函数调用四种方式:
 * 1. 作为函数
 * 2. 作为方法
 * 3. 作为构造函数
 * 4. 通过它们的 call() 和 apply() 方法间接调用
*/

在函数调用结束后继续调用返回值中的方法                      f().m()

// 嵌套函数

// self 指外部函数的 this 值

清理 setInterval()                                          var t = setInterval(function(){console.log("1")},1000); clearInterval(t)
清理 setTimeout()                                           var t = setTimeout(function(){console.log("1")},1000); clearTimeout(t)

// for 函数等不是一个作用域, 保持对外部变量的引用

返回事件被触发时鼠标指针指向对于浏览器页面的水平距离        event.clientX
返回事件被触发时鼠标指针指向对于浏览器页面的纵向距离        event.clientY
返回事件被触发时鼠标指针相对于屏幕的水平距离                event.screenX
返回事件被触发时鼠标指针相对于屏幕的纵向距离                event.screenY
返回元素的完整的高度, 忽略滚动条和 overflow                 HTMLElement.scrollHeight
返回元素的完整的宽度, 忽略滚动条和 overflow                 HTMLElement.scrollWidth
返回滚动到元素左边界像素, 有滚动条方有用, overflow: auto    HTMLElement.scrollLeft
返回滚动到元素上边界像素, 有滚动条方有用, overflow: auto    HTMLElement.scrollTop

// offsetLeft, offsetWidth 没有设置作用, 只有返回作用, 需要设置使用 left, position

返回可视部分宽度                                            HTMLElement.clientWidth
返回可视部分高度                                            HTMLElement.clientHeight
获得滚动条纵向滚动数据                                      document.body.scrollTop
获得滚动条横向滚动数据                                      document.body.scrollWidth

======================== this 常见误解 =======================

http://bit.ly/1jaIKDX
----------------------

Foo.method = function() {
  function test() {
    // this 将会被设置为全局对象 (即 window 对象)
  }
  test();
}

// 一个常见的误解是 test 中的 this 将会指向 Foo 对象, 实际上不是这样子的
// 为了在 test 中获取对 Foo 对象的引用, 我们需要在 method 函数内部创建一个局部变量指向 Foo 对象

Foo.method = function() {
  var that = this;
  function test() {
    // 使用 that 来指向 Foo 对象, 主要是防止在闭包使用 this 时是指向 window, 所以用 that 防止指向错误
  }
  test();
}

==============================================================

05-13-2014

==================== 循环中的闭包 ======================

http://bit.ly/1jaIKDX
----------------------

// 一个常见的错误出现在循环中使用闭包

function(var i=0;i<10;i++) {
  setTimeout(function() {
    console.log(i);            
  },1000);              // 重点是它不是自执行函数
}

// 上面的代码不会输出数字 0 到 9, 而是会输出数字 10 十次。
// 当 console.log 被调用的时候, 匿名函数保持对外部变量 i 的引用, 此时 for 循环已经结束, i 的值被修改为成了 10。for 语句中闭包第二层收不到每次的 i, 只会在结束后收到。

//为了得到想要的结果, 需要在每次循环中创建变量 i 的拷贝。为了正确的获得循环序号, 最好使用匿名包裹器 (即自执行匿名函数)。

for(var i=0;i<10;i++) {
  (function(e) {
     setTimeout(function() {
        console.log(e);   
      },1000);
   })(i);
}

// 外部的匿名函数会立即执行, 并把 i 作为它的参数, 此时函数内 e 的变量就拥有了 i 的一个拷贝。当传递给 setTimeout 的匿名函数执行时, 它就拥有了对 e 的引用, 而这个值是不会被循环改变的。

// 有另一个方法完成同样的工作; 那就是从匿名包装其中返回一个函数。这和上面的代码效果一样。

for(var i=0;i<10;i++) {
  setTimeout((function(e){
                console.log(e);    
              })(i),1000);
}
========================================================

// arguments 变量不是一个数组 (Array)。尽管在语法上它有数组相关的属性 length, 但它不从 Array.prototype 继承, 实际上它是一个对象 (Object)。因此, 无法对 arguments 变量使用标准的数组方法, 比如 push, pop 或者 slice。虽然使用 for 循环遍历也是可以的, 但是为了更好地使用数组方法, 最好把它转化为一个真正的数组。

+/- 具有转 String 为 int 能力                           +"10" ===10 //true

=========================== 闭包交互 ======================================

// 由于闭包的关系, 你不能直接访问到函数内部定义的函数, 不过可以采取映射出来

function outerFn() {
  var outerVar = 0;
  document.write("Outer function<br>");
  function innerFn() {
    outerVar++;
    document.write("Inner functioni 1 \t");
    document.write("outerVar = "+ outerVar + "<br>");
  }
  function innerFn2() {
    outerVar +=2;
    document.write("Inner Function 2 \t");
    document.write("outerVar = " + outerVar + "<br>");
  }
  return ("fn1":innerFn1, "fn2": innerFn2);
}

===========================================================================

===================== 闭包常见错误解析 ====================

var time = 0;
var span = [1,2,3,4];
for(var i=0;i<span.length;i++) {
  var t = setTimeout(
              function() {
                console.log(span[i]);
              },1000)
}

// 这里的闭包事实上是在等 for 循环到 4 时才会被执行的, 也就是之前并没有得到 i 的引用, 解决这个问题是使用匿名报过器(自执行匿名函数)。

===========================================================

======================= 关于 && 和 || ======================

a && b : 将a, b转换为Boolean类型, 再执行逻辑与, true返回b, false返回a 
a || b : 将a, b转换为Boolean类型, 再执行逻辑或, true返回a, false返回b 
转换规则: 
对象为true 
非零数字为true 
非空字符串为true 
其他为false 

============================================================

// 看来 clientX, clientY, screenX, screenY 不支持 doctype 文档类型声明啊

05-14-2014

=================== 构建 addEvent ================

@param node         监听事件
@param type         监听类型
@param listener     触发事件
@return             时间是否添加成功

function addEvent(node, type, listener) {
  if(node.addEventListener) {
    node.addEventListener(type,listener,false);
    return true;
  } else if(node.attachEvent) {
    node['e' + type + listener] = listener;
    node[type + listener] = function() {
      node['e' + type + listener](window.event);
    };
    node.attachEvent('on' + type, node[type + listener]);
    return true;
  }
  return false;
}

==================================================

// call 和 apply 其实就是一种处理闭包的方法, 可以将一个对象的 参数/方法 传递给另一个对象。两者产生的效果或作用完全相同, 都至少有一个参数 (传递目标), 

05-15-2014

指定当前正在执行的函数                          arguments.callee[(argument...)]

================ arguements.callee ==================

// 阶乘

function create() {
   return function(n) {
      if (n <= 1)
         return 1;
      return n * arguments.callee(n - 1);
   };
}

var result = create()(5); // returns 120 (5 * 4 * 3 * 2 * 1)

=====================================================

05-19-2014

===================== Cookie ===================

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Cookie Control</title>
</head>

<body>
  Username: <input type="text" size="20" placeholder="username">
  <br>
  <button onclick="addCookie()">Add Cookie</button>&nbsp;&nbsp;&nbsp;&nbsp;<button onclick="showCookie()">Show cookie</button>&nbsp;&nbsp;&nbsp;&nbsp;
  <button onclick="deleteCookie()">Delete Cookie</button>
  <br>

  <script type="text/javascript">
    var expiresTime = new Date();
    expiresTime.setTime(expiresTime.getTime()+5*3600*1000);

    function addCookie() {
      var usernameNode=document.getElementsByTagName("INPUT")[0];
      var cookieName=usernameNode.previousSibling.nodeValue.split(":")[0];
      document.cookie=escape(cookieName.trim())+"="+escape(usernameNode.value.trim())+";expires="+expiresTime.toGMTString();
    }

    function deleteCookie() {
      var usernameNode=document.getElementsByTagName("INPUT")[0];
      var cookieName=usernameNode.previousSibling.nodeValue.split(":")[0];
      document.cookie=escape(cookieName.trim())+"="+escape(usernameNode.value.trim())+";expires=Thu, 01 Jan 1970 00:00:00 GMT";
    }

    function showCookie() {
      if(document.cookie.split(";")[1]) {
        var cookie=document.cookie;
        var cookieName=cookie.split(";")[1].split("=")[0];
        var username=cookie.split(";")[1].split("=")[1];

        var show=document.createElement("P");
        var showTxt=document.createTextNode(unescape(cookieName)+":"+unescape(username));
        show.appendChild(showTxt);
        document.body.appendChild(show);
      } else {
        alert("No cookie reserved yet!");
      }
    }
  </script>
</body>
</html>

================================================

事件在键盘按键被松开时发生                                  onkeyup="SomeJavaScriptCode"

==================== onkeyup ====================

function upperCase(x)
{
var y=document.getElementById(x).value
document.getElementById(x).value=y.toUpperCase()
}

=================================================

接受一个指定的 Unicode 值, 然后返回一个字符串               String.fromCharCode(numX, numX, ..., numX);

======================== String.fromCharCode =====================

document.write(String.fromCharCode(72,69,76,76,79))     // HELLO
document.write("<br />")
document.write(String.fromCharCode(65,66,67))           // ABC

==================================================================

事件在用户按下一个键盘按键时发生                            onkeydown="SomeJavaScriptCode"

======================= onkeydown =====================

function noNumbers(e) {
  var keynum
  var keychar
  var numcheck

  if(window.event) {        // IE
  keynum = e.keyCode
  } else if(e.which) {      // not IE
  keynum = e.which
  }

  keychar = String.fromCharCode(keynum)
  numcheck = /\d/
  return !numcheck.test(keychar)
}

=======================================================

获取 error                                                  try { ... } catch(e) { ... }
获取所有的属性返回数组                                      document.getElementById("id").attributes;

06-15-2014

reduce 方法遍历数组(有参数)                                 arr.reduce(callback, [initialValue])

===================== arr.reduce ========================

arr.reduce(function(previousValue, currentValue, index, array){
  return previousValue + current Value;
});

var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {
    return a.concat(b);
});
// flattened is [0, 1, 2, 3, 4, 5]

=========================================================

从右到左遍历数组                                            Array.prototype.reduceRight()
遍历数组(直接操作数据)                                      arr.map(callback[, thisArg])

================================= Array.prototype.map() =======================

var numbers = [1, 4, 9];
var roots = numbers.map(Math.sqrt);
/* roots is now [1, 2, 3], numbers is still [1, 4, 9] */

var map = Array.prototype.map
var a = map.call("Hello World", function(x) { return x.charCodeAt(0); })
// a now equals [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]

[].map.call(document.querySelectorAll('select option:checked'), function(obj) {
    console.log(obj.parentNode.id, obj.value);
})

===============================================================================

更简单的数组循环                                            arr = [1...10]
                                                            cube = (num) -> Math.pow num,3
                                                            arr.map cube

06-16-2014

大于或等于                                                  x >= 8
小于或等于                                                  x <= 8

======================== 关于 String.prototype.replace ======================

// ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整体，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。

// 将华氏温度转换为摄氏温度

function f2c(x) {
  function convert(str, p1, offset, s) {
    return (p1-32)*5/9)+"C";
  }
  var s = String(x);
  var test = /(\d+(?:\.\d*)?F\b/g;
  return s.replace(test, convert);
}

=============================================================================

// apply 调用上下文, 另外函数 apply 给对象时就已经执行了这个函数

06-17-2014

加入收藏                                        <a href="javascript:window.external.AddFavorite('http://www.chinesedragon.com.cn','中国龙')">加入收藏</a>
设为主页                                        <a onclick="this.style.behavior=’url(#default#homepage)’;this.setHomePage(’http://www.chinesedragon.com.cn’);" href="#">设为首页</a>
把对象类型转为字符类型                          JSON.stringify(object)

// console.log(arr) 等同于 console.log(arr.join(','))

设置时间戳                                      t = new Date(2014, 6, 17);

===================== callback 示例 ==========================

function A(a,callback){
  var b=callback;
  alert(a+b);
}
function B(c){
  return (-c);
}

==============================================================

Error 对象                                      Error.name/message/number

====================== try catch finally =======================

try {
    document.write("Outer try running...<br/>");

    try {
        document.write("Nested try running...<br/>");
        throw new Error(301, "an error");
    }
    catch (e) {
        document.write ("Nested catch caught " + e.message + "<br/>");
        throw e;
    }
    finally {
        document.write ("Nested finally is running...<br/>");
    }
}
catch (e) {
    document.write ("Outer catch caught " + e.message + "<br/>");
}
finally {
    document.write ("Outer finally running");
}

================================================================


